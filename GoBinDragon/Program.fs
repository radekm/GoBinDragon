
open System
open System.IO

module UJson = UseData.Json.Json

// CONSIDER: Support generic parameters?

// ::UseData.Json.Generator::
type Type =
    | Ident of name:string
    | Selector of path:Type * name:string
    | Star of Type
    | Func of FuncType
    | Map of key:Type * value:Type
    | Array of len:int option * elem:Type
    | Struct of incomplete:bool * fields:Field[]
    | Interface of incomplete:bool * methods:Field[]  // Methods must have function types.

    // ::BEGIN:Generated by UseData.Json.Generator::
    static member ParseJson(v : UseData.Json.JsonValue) : Type =
        match v |> UJson.field "Case" UJson.string with
        | "Ident" -> v |> UJson.field "Fields" (UJson.tuple1 UJson.string) |> Ident
        | "Selector" -> v |> UJson.field "Fields" (UJson.tuple2 Type.ParseJson UJson.string) |> Selector
        | "Star" -> v |> UJson.field "Fields" (UJson.tuple1 Type.ParseJson) |> Star
        | "Func" -> v |> UJson.field "Fields" (UJson.tuple1 FuncType.ParseJson) |> Func
        | "Map" -> v |> UJson.field "Fields" (UJson.tuple2 Type.ParseJson Type.ParseJson) |> Map
        | "Array" -> v |> UJson.field "Fields" (UJson.tuple2 (UJson.nullable UJson.int >> function ValueNone -> None | ValueSome x -> Some x) Type.ParseJson) |> Array
        | "Struct" -> v |> UJson.field "Fields" (UJson.tuple2 UJson.bool (UJson.map Field.ParseJson)) |> Struct
        | "Interface" -> v |> UJson.field "Fields" (UJson.tuple2 UJson.bool (UJson.map Field.ParseJson)) |> Interface
        | case -> failwithf "Unrecognized case '%s' in union Type" case
    // ::END:Generated by UseData.Json.Generator::

// ::UseData.Json.Generator::
and Field =
    { Name : string
      Type : Type }

    // ::BEGIN:Generated by UseData.Json.Generator::
    static member ParseJson(v : UseData.Json.JsonValue) : Field =
        { Name = v |> UJson.field "Name" UJson.string
          Type = v |> UJson.field "Type" Type.ParseJson
        }
    // ::END:Generated by UseData.Json.Generator::

/// Field which may not have a name.
// ::UseData.Json.Generator::
and ResultField =
    { Name : string option
      Type : Type }

    // ::BEGIN:Generated by UseData.Json.Generator::
    static member ParseJson(v : UseData.Json.JsonValue) : ResultField =
        { Name = v |> UJson.fieldOpt "Name" UJson.string |> function ValueNone -> None | ValueSome x -> Some x
          Type = v |> UJson.field "Type" Type.ParseJson
        }
    // ::END:Generated by UseData.Json.Generator::

// ::UseData.Json.Generator::
and FuncType =
    { Params : Field[]
      Results : ResultField[] }

    // ::BEGIN:Generated by UseData.Json.Generator::
    static member ParseJson(v : UseData.Json.JsonValue) : FuncType =
        { Params = v |> UJson.field "Params" (UJson.map Field.ParseJson)
          Results = v |> UJson.field "Results" (UJson.map ResultField.ParseJson)
        }
    // ::END:Generated by UseData.Json.Generator::

// ::UseData.Json.Generator::
type Decl =
    | Import  // TODO: Add info.
    | Type of name:string * Type
    | Const of name:string  // TODO: Add more info.
    | Var of name:string  // TODO: Add more info.
    // Top-level function declaration may have receiver.
    | Func of name:string * receiver:Field option * FuncType

    // ::BEGIN:Generated by UseData.Json.Generator::
    static member ParseJson(v : UseData.Json.JsonValue) : Decl =
        match v |> UJson.field "Case" UJson.string with
        | "Import" -> Import
        | "Type" -> v |> UJson.field "Fields" (UJson.tuple2 UJson.string Type.ParseJson) |> Type
        | "Const" -> v |> UJson.field "Fields" (UJson.tuple1 UJson.string) |> Const
        | "Var" -> v |> UJson.field "Fields" (UJson.tuple1 UJson.string) |> Var
        | "Func" -> v |> UJson.field "Fields" (UJson.tuple3 UJson.string (UJson.nullable Field.ParseJson >> function ValueNone -> None | ValueSome x -> Some x) FuncType.ParseJson) |> Func
        | case -> failwithf "Unrecognized case '%s' in union Decl" case
    // ::END:Generated by UseData.Json.Generator::

let tracer = { new UseData.Json.ITracer with
                 override this.OnUnusedFields(which, fields) = printfn "Unused fields in %A: %A" which fields }

[<EntryPoint>]
let main args =
    if args.Length <> 1 then
        failwith "JSON file with Go declarations expected"
    let data = File.ReadAllBytes(args[0])
    let result = UseData.Json.JsonValue.parseWhole (tracer) (Memory data) 50 (UJson.map Decl.ParseJson)
    printfn "Parsed %A" result
    0
